<h1> Extract Variables policy </h1>
<img src="sites/docs/files/icon_policy_extract-variable.jpg" />&nbsp;
<h3>What</h3>
<p>Extract content from a variable. Often the source variable contains a request or response messages, including headers, URI paths, JSON/XML payloads, form parameters, and query parameters. The policy works by applying a text pattern to the message content and, upon finding a match, sets a variable with the specified message content.</p>
<p>While you often use this policy to extract information from a request or response message, you can use it to extract information from any variable. For example, you can use it to extract information from an entity created by the <a href="http://docs.apigee.com/node/422">http://docs.apigee.com/node/422</a>, or extract information from an XML or JSON object.</p>
<p>After extracting the specified message content to the variable, you can reference the variable in other policies as part of processing a request and response.&nbsp;</p>
<div class="note">
	<p><strong>Note about Service Callouts</strong>: You aren't required to use this policy to extract variables from Service Callouts. The <a href="http://docs.apigee.com/node/156">http://docs.apigee.com/node/156</a> has its own request and response variables that you can use directly, for example in an Assign Message policy.</p>
</div>
<h3>Where</h3>
<p>This policy can be attached in the following locations.&nbsp;</p>
<table cellspacing="0" style="font-family:Segoe, 'Segoe UI', 'DejaVu Sans', 'Trebuchet MS', Verdana, sans-serif" width="650">
	<tbody>
		<tr bgcolor="#e5e5e5" style="font-size:13px; line-height:20px" valign="middle">
			<td class="bbdbrd" colspan="5" style="text-align: center">ProxyEndpoint</td>
			<td class="bbd" colspan="5" style="text-align: center">TargetEndpoint</td>
		</tr>
		<tr bgcolor="#f4f4f4" style="font-size:12px; line-height:20px" valign="middle">
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td style="text-align: center">PreFlow</td>
			<td style="text-align: center">Flow</td>
			<td class="brl" style="text-align: center">PostFlow</td>
			<td style="text-align: center">PreFlow</td>
			<td style="text-align: center">Flow</td>
			<td style="text-align: center">PostFlow</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr style="font-size:36px; line-height:24px" valign="middle">
			<td class="bbl" style="text-align: right; font-size:13px; font-style:italic">Request</td>
			<td class="bbl" style="text-align:center; font-size:16px">→</td>
			<!-- Start request dots. Option+8 for dot. Third dot is bblbrl class. -->
			<td class="bbl" style="text-align: center; color: #7DD31F">•</td>
			<td class="bbl" style="text-align: center; color: #7DD31F">•</td>
			<td class="bblbrl" style="text-align: center; color: #7DD31F">•</td>
			<td class="bbl" style="text-align: center; color: #7DD31F">•</td>
			<td class="bbl" style="text-align: center; color: #7DD31F">•</td>
			<td class="bbl" style="text-align: center; color: #7DD31F">•</td>
			<!-- End request dots -->
			<td class="bbl">&nbsp;</td>
			<td class="bbl">&nbsp;</td>
		</tr>
		<tr style="font-size:36px; line-height:24px" valign="middle">
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<!-- Start response dots. Option+8 for dot. Third dot is brl class. -->
			<td style="text-align: center; color: #7DD31F">•</td>
			<td style="text-align: center; color: #7DD31F">•</td>
			<td class="brl" style="text-align: center; color: #7DD31F">•</td>
			<td style="text-align: center; color: #7DD31F;">•</td>
			<td style="text-align: center; color: #7DD31F;">•</td>
			<td style="text-align: center; color: #7DD31F;">•</td>
			<!-- End response dots -->
			<td style="text-align:center; font-size:16px">←</td>
			<td style="text-align: left; font-size:13px; font-style:italic">Response</td>
		</tr>
		<tr bgcolor="#f4f4f4" style="font-size:12px; line-height:20px" valign="middle">
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td style="text-align: center">PostFlow</td>
			<td style="text-align: center">Flow</td>
			<td class="brl" style="text-align: center">PreFlow</td>
			<td style="text-align: center">PostFlow</td>
			<td style="text-align: center">Flow</td>
			<td style="text-align: center">PreFlow</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>
<h2 id="samples">Samples</h2>
<p>These policy code samples illustrate how to extract variables from the following types of artifacts:</p>
<ul class="nav nav-tabs" id="myTab">
	<li class="active"><a data-toggle="tab" href="#tab_a">Videos</a></li>
	<li><a data-toggle="tab" href="#gittab">GitHub</a></li>
	<li><a data-toggle="tab" href="#url">URIs</a></li>
	<li><a data-toggle="tab" href="#query">Query params</a></li>
	<li><a data-toggle="tab" href="#multiquery">Multiple params</a></li>
	<li><a data-toggle="tab" href="#header">Headers</a></li>
	<li><a data-toggle="tab" href="#json">JSON</a></li>
	<li><a data-toggle="tab" href="#xml">XML</a></li>
</ul>
<div class="tab-content active"><!-- Tab a begin. -->
	<div class="tab-pane active" id="tab_a"><iframe allowfullscreen="" frameborder="0" height="390" src="https://www.youtube.com/embed/arVPRaL4qQk" width="640"></iframe><br />
		<iframe allowfullscreen="" frameborder="0" height="390" src="https://www.youtube.com/embed/G0XnHRELeBA" width="640"></iframe></div>
	<!-- Tab a end. --><!--This is the URL tab-->
	<div class="tab-pane" id="gittab">
		<div class="sample-github">
			<p><strong>Learn by doing!</strong><br />
				Check out these Learn Edge examples that show you how to extract data from a JSON and XML response payloads. Just follow the instructions in the READMEs.</p>
			<ul>
				<li><a href="https://github.com/apigee/api-platform-samples/tree/master/learn-edge/extract-json-payload">Extract data from a JSON payload</a></li>
				<li><a href="https://github.com/apigee/api-platform-samples/tree/master/learn-edge/extract-json-payload-2">Query for data in a JSON payload</a></li>
				<li><a href="https://github.com/apigee/api-platform-samples/tree/master/learn-edge/extract-xml-payload">Extract data from an XML payload</a></li>
			</ul>
		</div>
		<p>These links point to working API proxy samples that you can deploy and run on Edge. They use ExtractVariables and are located in Apigee's&nbsp;<a href="https://github.com/apigee/api-platform-samples">api-platform-samples repository</a> on GitHub. The READMEs explain how ExtractVariables is used in each case, and how to deploy and run each sample.&nbsp;</p>
		<ul>
			<li><a href="https://github.com/apigee/api-platform-samples/tree/master/sample-proxies/variables">Extract and assign variables sample</a>&nbsp;(extract data from JSON and XML messages)</li>
			<li><a href="https://github.com/apigee/api-platform-samples/tree/master/sample-proxies/access-entity">Access entity &nbsp;sample</a></li>
			<li><a href="https://github.com/apigee/api-platform-samples/tree/master/sample-proxies/pagination">Pagination and caching sample</a></li>
			<li><a href="https://github.com/apigee/api-platform-samples/tree/master/sample-proxies/target-reroute">Reroute a target URL sample</a></li>
			<li><a href="https://github.com/apigee/api-platform-samples/tree/master/doc-samples/policy-mashup-cookbook">Policy composition mashup sample</a></li>
			<li><a href="https://github.com/apigee/streetcarts">Streetcarts sample</a></li>
		</ul>
	</div>
	<!-- Tab a end. --><!--This is the URL tab-->
	<div class="tab-pane" id="url">
		<pre>
&lt;ExtractVariables name="ExtractVariables-1"&gt;
   &lt;DisplayName&gt;Extract a portion of the url path&lt;/DisplayName&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   &lt;URIPath&gt;
      &lt;Pattern ignoreCase="true"&gt;/accounts/{id}&lt;/Pattern&gt;
   &lt;/URIPath&gt;
   &lt;VariablePrefix&gt;urirequest&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
		<p>Consider the sample policy code above. The <code>&lt;URIPath&gt;</code> element tells the Extract Variables policy to extract information from the URI path. The <code>&lt;Pattern&gt;</code> element specifies the pattern to apply to the URI path. The pattern is treated as a simple template, with the curly braces denoting the varying portion of the URI path.</p>
		<p>The name of the variable to be set is determined by the value specified in the <code>&lt;VariablePrefix&gt;</code> element, as well as the value enclosed in curly braces {} in the <code>&lt;Pattern&gt;</code> element. The two values are joined by an intervening dot, resulting in a variable name of <code>urirequest.id</code> for example. If there is no <code>&lt;VariablePrefix&gt;</code> element, then the variable name is just the value enclosed in curly braces.</p>
		<p>Consider the sample policy code above working with the following incoming request:</p>
		<p><code>GET http://org1-test.apigee.net/accounts/12797282</code></p>
		<p>When Apigee Edge applies the Extract Variables policy code above to this incoming request, it sets the variable <code>urirequest.id</code> to <code>12797282</code>. After Apigee Edge executes the policy, subsequent policies or code in the processing flow can refer to the variable named <code>urirequest.id</code> to get the string value <code>12797282</code>.</p>
		<p>You can now access the variable&nbsp;<code>urirequest.id</code>&nbsp;in your proxy. For example, the following AssignMessage policy copies it to the payload of the request:</p>
		<pre>
&lt;AssignMessage async="false" continueOnError="false" enabled="true" name="GetURIPath"&gt;
 &lt;DisplayName&gt;GetURIPath&lt;/DisplayName&gt;
  &lt;Set&gt;
   &lt;Payload contentType="text/xml"&gt;
    &lt;ExtractURI&gt;{urirequest.id}&lt;/ExtractURI&gt;
   &lt;/Payload&gt;
  &lt;/Set&gt;
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
  &lt;AssignTo createNew="false" transport="http" type="request"/&gt;
&lt;/AssignMessage&gt;
</pre>
	</div>
	<!--This is the Query param tab-->
	<div class="tab-pane" id="query">
		<pre>
&lt;ExtractVariables name="ExtractVariables-2"&gt;
   &lt;DisplayName&gt;Extract a value from a query parameter&lt;/DisplayName&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   &lt;QueryParam name="code"&gt;
      &lt;Pattern ignoreCase="true"&gt;DBN{dbncode}&lt;/Pattern&gt;
   &lt;/QueryParam&gt;
   &lt;VariablePrefix&gt;queryinfo&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
		Consider the sample policy code above. Suppose that your API design stipulates that incoming requests must carry a query parameter named <code>code</code>. <code>code</code> holds a term that looks like <code>DBN<em>XXXXX</em></code>, where <code>DBN</code> is fixed and the <code><em>XXXXX</em></code> denotes a varying string. You can use this policy to extract the varying string.
		<p>Consider the sample policy code above working with the following incoming request:</p>
		<p><code>GET http://org1-test.apigee.net/accounts/12797282?code=DBN88271</code></p>
		<p>When Apigee Edge applies the Extract Variables policy code above to this incoming request, it sets the variable <code>queryinfo.dbncode</code> to <code>88271</code>. After Apigee Edge executes the policy, subsequent policies or code in the processing flow can refer to the variable named <code>queryinfo.dbncode</code> to get the string value <code>88271</code>.</p>
		<p>You can now access the variable&nbsp;<code>queryinfo.dbncode</code>&nbsp;in your proxy. For example, the following AssignMessage policy copies it to the payload of the request:</p>
		<pre>
&lt;AssignMessage async="false" continueOnError="false" enabled="true" name="GetURIPath"&gt;
 &lt;DisplayName&gt;GetQP&lt;/DisplayName&gt;
  &lt;Set&gt;
   &lt;Payload contentType="text/xml"&gt;
    &lt;ExtractQP&gt;{queryinfo.dbncode}&lt;/ExtractQP&gt;
   &lt;/Payload&gt;
  &lt;/Set&gt;
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
  &lt;AssignTo createNew="false" transport="http" type="request"/&gt;
&lt;/AssignMessage&gt;
</pre>
	</div>
	<!--This is the multiQuery param tab-->
	<div class="tab-pane" id="multiquery">
		<pre>
&lt;ExtractVariables name="ExtractVariables-2"&gt;
   &lt;DisplayName&gt;Extract a value from a query parameter&lt;/DisplayName&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   &lt;QueryParam name="w"&gt;
      &lt;Pattern ignoreCase="true"&gt;{firstWeather}&lt;/Pattern&gt;
   &lt;/QueryParam&gt;
   &lt;QueryParam name="w.2"&gt;
     &lt;Pattern ignoreCase="true"&gt;{secondWeather}&lt;/Pattern&gt;
   &lt;/QueryParam&gt;
   &lt;VariablePrefix&gt;queryinfo&lt;/VariablePrefix&gt;
 &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
		<p>Suppose your API design allows you to specify multiple query paramaters with the same name. You can use this policy to extract the value of multiple instances of the query parameter "w".&nbsp;​To reference these query parameters in the Extract Variables policy, you use indexes, where the first instance of the query parameter has no index, the second is at index 2, the third at index 3, etc.</p>
		<p>Consider the sample policy code above working with the following incoming request:</p>
		<p><code>GET http://org1-test.apigee.net/weather?w=Boston&amp;w=Chicago</code></p>
		<p>When Apigee Edge applies the Extract Variables policy code above to this incoming request, it sets the variable <code>queryinfo.firstWeather</code> to <code>Boston</code> and the variable <code>queryInfo.secondWeather</code> to <code>Chicago</code>.&nbsp;</p>
		<p>You can now access the variable&nbsp;<code>queryinfo.firstWeather</code>&nbsp;and <span style="font-family:courier new,courier,monospace;">queryinfo.secondWeather</span> in your proxy. For example, the following AssignMessage policy copies it to the payload of the request:</p>
		<pre>
&lt;AssignMessage async="false" continueOnError="false" enabled="true" name="GetURIPath"&gt;
 &lt;DisplayName&gt;GetQP&lt;/DisplayName&gt;
  &lt;Set&gt;
   &lt;Payload contentType="text/xml"&gt;
    &lt;ExtractQP1&gt;{queryinfo.firstWeather}&lt;/ExtractQP1&gt;
    &lt;ExtractQP2&gt;{queryinfo.secondWeather}&lt;/ExtractQP2&gt;
   &lt;/Payload&gt;
  &lt;/Set&gt;
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
  &lt;AssignTo createNew="false" transport="http" type="request"/&gt;
&lt;/AssignMessage&gt;
</pre>
	</div>
	<div class="tab-pane" id="header">
		<pre>
&lt;ExtractVariables name='ExtractVariable-OauthToken'&gt;
  &lt;Source&gt;request&lt;/Source&gt;
  &lt;Header name="Authorization"&gt;
    &lt;Pattern ignoreCase="false"&gt;Bearer {oauthtoken}&lt;/Pattern&gt;
  &lt;/Header&gt;
  &lt;VariablePrefix&gt;clientrequest&lt;/VariablePrefix&gt;
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
		<p>Suppose that your API uses OAuth v2.0 bearer tokens. Consider the sample policy code above working with a request carrying an OAuth v2.0 token that includes a header like this: <code>Authorization: Bearer TU08xptfFfeM7aS0xHqlxTgEAdAM. </code></p>
		<p>As the API designer, suppose that you want to use the token value (but not the entire header) as a key in a cache lookup. You could use the Extract Variables policy code above to extract the token.</p>
		<p>When Apigee Edge applies the Extract Variables policy code above to this header, it will set the variable <code>clientrequest.oauthtoken</code> to <code>TU08xptfFfeM7aS0xHqlxTgEAdAM</code>.</p>
		<p>You can now access the variable&nbsp;<code>clientrequest.oauthtoken</code>&nbsp;in your proxy. For example, the following AssignMessage policy copies it to the payload of the request:</p>
		<pre>
&lt;AssignMessage async="false" continueOnError="false" enabled="true" name="GetURIPath"&gt;
 &lt;DisplayName&gt;GetHeader&lt;/DisplayName&gt;
  &lt;Set&gt;
   &lt;Payload contentType="text/xml"&gt;
    &lt;ExtractHeader&gt;{clientrequest.oauthtoken}&lt;/ExtractHeader&gt;
   &lt;/Payload&gt;
  &lt;/Set&gt;
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
  &lt;AssignTo createNew="false" transport="http" type="request"/&gt;
&lt;/AssignMessage&gt;
</pre>
	</div>
	<div class="tab-pane" id="json">
		<pre>
&lt;ExtractVariables name="ExtractVariables-3"&gt;
   &lt;Source&gt;response&lt;/Source&gt;
   &lt;JSONPayload&gt;
      &lt;Variable name="latitude" type="float"&gt;
         &lt;JSONPath&gt;$.results[0].geometry.location.lat&lt;/JSONPath&gt;
      &lt;/Variable&gt;
      &lt;Variable name="longitude" type="float"&gt;
         &lt;JSONPath&gt;$.results[0].geometry.location.lng&lt;/JSONPath&gt;
      &lt;/Variable&gt;
   &lt;/JSONPayload&gt;
   &lt;VariablePrefix&gt;geocoderesponse&lt;/VariablePrefix&gt;
&lt;/ExtractVariables&gt;</pre>
		The Extract Variables policy can extract values from complex structures, such as JSON messages. The sample policy code above shows how to extract a variable from a portion of a JSON message payload. The <code>&lt;JSONPayload&gt;</code> element tells the policy to extract a variable from a JSON payload. You specify the portion to extract using a JSON path expression in which the <code>$</code> character refers to the root node of the JSON message.
		<p>Consider the following JSON response payload:</p>
		<pre>
{
  "results": [{
    "geometry": {
      "location": {
        "lat": 37.42291810,
        "lng": -122.08542120
      },
      "location_type": "ROOFTOP",
      "viewport": {
        "northeast": {
          "lat": 37.42426708029149,
          "lng": -122.0840722197085
        },
        "southwest": {
          "lat": 37.42156911970850,
          "lng": -122.0867701802915
        }
      }
    }
  }]
}</pre>
		<p>When Apigee Edge applies the Extract Variables policy code above to this JSON message, it sets two variables: <code>geocoderesponse.latitude</code> and <code>geocoderesponse.longitude</code>. Both variables use the same variable prefix of <code>geocoderesponse</code>. The suffix for these variables is specified explicitly by the <code>&lt;Variable&gt;</code> element's <code>name</code> attribute.</p>
		<p>The variable <code>geocoderesponse.latitude</code> gets the value <code>37.42291810</code>. The variable <code>geocoderesponse.longitude</code> gets the value <code>-122.08542120</code>.</p>
		<p>You can now access the variable&nbsp;<code>geocoderesponse.latitude</code>&nbsp;in your proxy. For example, the following AssignMessage policy copies it to a header named "latitude" in the response:</p>
		<pre>
&lt;AssignMessage async="false" continueOnError="false" enabled="true" name="GetURIPath"&gt;
  &lt;DisplayName&gt;GetJSONVar&lt;/DisplayName&gt;
  &lt;Add&gt;
    &lt;Headers&gt;
      &lt;Header name="latitude"&gt;{geocoderesponse.latitude}&lt;/Header&gt;
    &lt;/Headers&gt;
  &lt;/Add&gt; 
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
  &lt;AssignTo createNew="false" transport="http" type="response"/&gt; 
&lt;/AssignMessage&gt;</pre>
	</div>
	<div class="tab-pane" id="xml">
		<pre>
&lt;ExtractVariables name="ExtractVariables-4"&gt;
   &lt;Source&gt;response&lt;/Source&gt;
   &lt;XMLPayload&gt;
      &lt;Namespaces&gt;
         &lt;Namespace prefix="dir"&gt;urn:43BFF88D-D204-4427-B6BA-140AF393142F&lt;/Namespace&gt;
      &lt;/Namespaces&gt;
      &lt;Variable name="travelmode" type="string"&gt;
         &lt;XPath&gt;/dir:Directions/dir:route/dir:leg/dir:step/@mode&lt;/XPath&gt;
      &lt;/Variable&gt;
      &lt;Variable name="duration" type="string"&gt;
         &lt;XPath&gt;/dir:Directions/dir:route/dir:leg/dir:step/dir:duration/dir:value&lt;/XPath&gt;
      &lt;/Variable&gt;
      &lt;Variable name="timeunit" type="string"&gt;
         &lt;XPath&gt;/dir:Directions/dir:route/dir:leg/dir:step/dir:duration/dir:text&lt;/XPath&gt;
      &lt;/Variable&gt;
   &lt;/XMLPayload&gt;
   &lt;VariablePrefix&gt;directionsresponse&lt;/VariablePrefix&gt;
&lt;/ExtractVariables&gt;</pre>
		The Extract Variables policy can extract values from complex structures, such as XML messages. The sample policy code above shows how to extract a variable from a portion of a XML message payload. The <code>&lt;XMLPayload&gt;</code> element tells the policy to extract a variable from an XMLpayload. You specify the portion to extract using XPath and explicitly named variables.
		<p>Consider the following XML response payload:</p>
		<pre>
&lt;Directions xmlns="urn:43BFF88D-D204-4427-B6BA-140AF393142F"&gt;
   &lt;status&gt;OK&lt;/status&gt;
   &lt;route&gt;
      &lt;summary&gt;I-40 W&lt;/summary&gt;
      &lt;leg&gt;
         &lt;step mode="DRIVING"&gt;
            &lt;start_location&gt;
               &lt;lat&gt;41.8507300&lt;/lat&gt;
               &lt;lng&gt;-87.6512600&lt;/lng&gt;
            &lt;/start_location&gt;
            &lt;end_location&gt;
               &lt;lat&gt;41.8525800&lt;/lat&gt;
               &lt;lng&gt;-87.6514100&lt;/lng&gt;
            &lt;/end_location&gt;
            &lt;duration&gt;
                &lt;value&gt;19&lt;/value&gt;
                &lt;text&gt;minutes&lt;/text&gt;
            &lt;/duration&gt;
         &lt;/step&gt;
      &lt;/leg&gt;
   &lt;/route&gt;
&lt;/DirectionsResponse&gt;</pre>
		<p>When Apigee Edge applies the Extract Variables policy code above to this XML message, it sets three variables: <code>directionsresponse.travelmode, </code><code>directionsresponse.duration</code>, and <code>directionsresponse.timeunit</code>. All variables use the same variable prefix of <code>directionsresponse</code>. The suffix for these variables is specified explicitly by the <code>&lt;Variable&gt;</code> element's <code>name</code> attribute.</p>
		<p>The variable <code>directionsresponse.travelmode</code> gets the value <code>DRIVING</code>. The variable <code>directionsresponse.duration</code> gets the value <code>19</code>. The variable <code>directionsresponse.timeunit</code> gets the value <code>minutes</code>.</p>
		<p>You can now access the variable&nbsp;<code>directionresponse.travelmode</code>&nbsp;in your proxy. For example, the following AssignMessage policy copies it to a header named "tmode" in the response:</p>
		<pre>
&lt;AssignMessage async="false" continueOnError="false" enabled="true" name="GetURIPath"&gt;
  &lt;DisplayName&gt;GetXMLVar&lt;/DisplayName&gt;
  &lt;Add&gt;
    &lt;Headers&gt;
      &lt;Header name="tmode"&gt;{directionsresponse.travelmode}&lt;/Header&gt;
    &lt;/Headers&gt;
  &lt;/Add&gt;
  &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
  &lt;AssignTo createNew="false" transport="http" type="request"/&gt;
&lt;/AssignMessage&gt;
</pre>
		<div class="note">
			<p><strong>Setting Content-Type</strong>: When extracting variables from XML messages (including SOAP), the variable extraction works only when Content-Type is set in the message header (or SOAP header); for example,&nbsp;<code>application/xml</code>.</p>
		</div>
	</div>
</div>
<hr />
<h2 id="usagenotes">About the Extract Variables policy</h2>
<p>API developers build API proxies that behave differently based on the content of messages, including headers, URI paths, payloads, and query parameters. Often, the proxy extracts some portion of this content for use in a condition statement. Use the Extract Variables policy to do this. Choose the names of the variables to be set, the source of the variables, and how many variables to extract and set. The policy then applies a text pattern to the content and upon finding a match sets a designated variable with the selected content.</p>
<p>Other policies and code can then consume those variables to enable dynamic behavior, or to send business data to Analytics Services.</p>
<p>To see how Extract Variables can be used to build content-driven Analytics reports, see <a href="http://docs.apigee.com/node/4554">http://docs.apigee.com/node/4554</a>.</p>
<div class="warning">Apigee Edge sets numerous variables automatically during request processing. See <a href="http://docs.apigee.com/node/243">http://docs.apigee.com/node/243</a>. Use the Extract Variables policy to set additional variables.</div>
<div class="tipstricks">
	<p>If you do not see the newly extracted variable show up in the Trace tool, try removing the &lt;VariablePrefix&gt; element if you added it. For more information, refer to this <a href="https://community.apigee.com/questions/164/extractvariables-not-shown-in-trace.html">Apigee Community topic</a>.</p>
</div>
<h2>About matching and variable creation</h2>
<p>The Extract Variables policy extracts information from a request or response and writes that information to a variable. For each type of information that you can extract, such as URI path or XML data, you specify the pattern to match and the name of the variable used to hold the extracted information.&nbsp;</p>
<p>However, the way pattern matching works depends on the source of the extraction. The following sections describe the two basic categories of information that you can extract.</p>
<h3>Matching URI paths, query parameters, headers, form parameters, and variables</h3>
<p>When extracting information from a URI path, query parameters, headers, form parameters, and variables you use the <span style="font-family:courier new,courier,monospace;">&lt;Pattern&gt;</span> tag to specify one or more patterns to match. For example, the following policy example shows a single matching pattern for the URI path:</p>
<pre>
&lt;ExtractVariables name="ExtractVariables-1"&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   &lt;URIPath&gt;
     <strong> &lt;Pattern ignoreCase="true"&gt;/a/{pathSeg}&lt;/Pattern&gt;</strong>
   &lt;/URIPath&gt;
   &lt;VariablePrefix&gt;urirequest&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
<p>In this example,&nbsp;the <span style="font-family: 'courier new', courier, monospace;">urirequest.pathSeg</span>&nbsp;variable is set to whatever appears in the pathsuffix after "/a/". For example, suppose the base path for your API Proxy is <span style="font-family: 'courier new', courier, monospace;">/basepath/v1</span> . With an inbound request to <span style="font-family: 'courier new', courier, monospace;">http://myCo.com/basepath/v1/a/b</span> the variable is set to "b".</p>
<h4>Specifying multiple patterns</h4>
<p>You can specify multiple patters to match, corresponding to&nbsp;<span style="font-family: 'courier new', courier, monospace;">&lt;Pattern&gt;</span>&nbsp;tags, where:</p>
<ul>
	<li>All patterns are tested for match.</li>
	<li>If none of the patterns match, the policy&nbsp;does nothing and the variable(s) is not created.</li>
	<li>If more than one pattern matches, the pattern with longest path segments is used for extraction.</li>
	<li>If two matched patterns has same longest path segments, then the pattern specified first in the policy is used for extraction.</li>
</ul>
<p>In the next example, you create a policy that contains three matching patterns for the URI path:</p>
<pre>
&lt;ExtractVariables name="ExtractVariables-1"&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   &lt;URIPath&gt;
      <strong>&lt;Pattern ignoreCase="true"&gt;/a/{pathSeg}&lt;/Pattern&gt;
&nbsp; &nbsp; &nbsp; &lt;Pattern ignoreCase="true"&gt;/a/b/{pathSeg}&lt;/Pattern&gt;
&nbsp; &nbsp; &nbsp; &lt;Pattern ignoreCase="true"&gt;/a/b/c/{pathSeg}&lt;/Pattern&gt;</strong>
   &lt;/URIPath&gt;
   &lt;VariablePrefix&gt;urirequest&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
<p>Suppose, for an API Proxy with a basepath of <span style="font-family: 'courier new', courier, monospace;">/basepath/v1</span> , the inbound request URL to the API proxy is of this form:</p>
<pre>
http://myCo.com/basepath/v1/a/b</pre>
<p>In this example, the first pattern matches the URI and&nbsp;the&nbsp;<span style="font-family: 'courier new', courier, monospace;">urirequest.pathSeg</span>&nbsp;variable&nbsp;is set to "b".</p>
<p>If the request URL is:</p>
<pre>
http://myCo.com/basepath/v1/a/b/c/d</pre>
<p>...then the third pattern matches and&nbsp;the&nbsp;<span style="font-family: 'courier new', courier, monospace;">urirequest.pathSeg</span>&nbsp;variable&nbsp;is set to "d".</p>
<h4>Specifying patterns with multiple variables</h4>
<p>You can specify multiple variables in the matching pattern. For example, you specify a matching pattern with two variables:</p>
<pre>
&lt;ExtractVariables name="ExtractVariables-1"&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   &lt;URIPath&gt;
      &lt;Pattern ignoreCase="true"&gt;/a/{pathSeg}&lt;/Pattern&gt;
&nbsp; &nbsp; &nbsp; &lt;Pattern ignoreCase="true"&gt;/a/b/{pathSeg}&lt;/Pattern&gt;
&nbsp; &nbsp; &nbsp; <strong>&lt;Pattern ignoreCase="true"&gt;/a/{pathSeg1}/c/{pathSeg2}&lt;/Pattern&gt;</strong>
   &lt;/URIPath&gt;
   &lt;VariablePrefix&gt;urirequest&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
<p>Again supposing an API Proxy with a base path of <span style="font-family: 'courier new', courier, monospace;">/basepath/v1</span> , for the inbound request URL:</p>
<pre>
http://myCo.com/basepath/v1/a/b/c/d</pre>
<p>...the&nbsp;<span style="font-family: 'courier new', courier, monospace;">urirequest.pathSeg1</span>&nbsp;variable&nbsp;is set to "b" and&nbsp;the&nbsp;<span style="font-family: 'courier new', courier, monospace;">urirequest.pathSeg2</span>&nbsp;variable&nbsp;is set to "d".</p>
<h4>Matching multiple instances in the pattern</h4>
<p>You can also match patterns when there are multiple instances of an item with the same name. For example, you can make a request that contains multiple query parameters or multiple headers with the same name. The following request contains two query parameters named "w":</p>
<pre>
http://myCo.com/basepath/v1/a/b/c/d?w=1&amp;w=2</pre>
<p>To reference these query parameters in the Extract Variables policy, you use indexes, where the first instance of the query parameter has no index, the second is at index 2, the third at index 3, etc. For example, the following policy extracts the value of the second query parameter named "w" in the request:</p>
<pre>
&lt;ExtractVariables name="ExtractVariables-1"&gt;
   &lt;Source&gt;request&lt;/Source&gt;
   <strong>&lt;QueryParam name="w.2"&gt;</strong>
      &lt;Pattern ignoreCase="true"&gt;{secondW}&lt;/Pattern&gt;
   &lt;/QueryParam&gt;
   &lt;VariablePrefix&gt;urirequest&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/ExtractVariables&gt;</pre>
<p>The&nbsp;<span style="font-family: 'courier new', courier, monospace;">urirequest.secondW</span>&nbsp;variable&nbsp;is set to "2". If the second query parameter is omitted from the request, then the&nbsp;<span style="font-family: 'courier new', courier, monospace;">urirequest.secondW</span>&nbsp;variable is empty. Use indexing any time there are multiple items with the same name in the request.</p>
<h4>Using special characters in the pattern</h4>
<p>When matching URI paths, you can use the "*" and "**" wildcard characters in the pattern, where:</p>
<ul>
	<li>"*" matches any one segments of the path</li>
	<li>"**" matches multiple segments of the path</li>
</ul>
<p>For example, you specify patterns to the <span style="font-family:courier new,courier,monospace;">&lt;URIPath&gt;</span> element&nbsp;as shown below:</p>
<pre>
&lt;URIPath&gt;
  &lt;Pattern ignoreCase="true"&gt;/a/*/{id}&lt;/Pattern&gt;
  &lt;Pattern ignoreCase="true"&gt;/a/**/{id}&lt;/Pattern&gt;
&lt;/URIPath&gt;
</pre>
<p>The first pattern matches requests with pathsuffixes (the portion of the URI path following the basepath) such as "/a/b/c", "/a/foo/bar", etc. The second pattern matches any number of path segments after "/a/", such as "/a/foo/bar/baz/c", as well as "/a/b/c" and "/a/foo/bar".</p>
<p>When specifying patterns to query parameters, headers, and form parameters, the "*"character specifies to match any number of characters. For example, when matching a header, specify the pattern as:</p>
<p><span style="font-family:courier new,courier,monospace;">*;charset={encoding}&nbsp;</span></p>
<p>This pattern matches the values "text/xml;charset=UTF-16" and "application/xml;charset=ASCII".</p>
<p>If the value passed to the Extract Variables policy contains a special&nbsp;character, such as "{", use the "%" character to escape it. The following example escapes the "{" and "}" characters in the pattern because they are used as literal characters in the value of the query parameter:</p>
<pre>
&lt;QueryParam&gt;
  &lt;Pattern ignoreCase="true"&gt;%{user%} {name}&lt;/Pattern&gt;
&lt;/QueryParam&gt;</pre>
<p>In this example, the pattern matches the value "{user} Steve" but not the value "user Steve".&nbsp;</p>
<h3>Matching JSON and XML</h3>
<p>When extracting data from&nbsp;JSON and XML, you specify one or more <span style="font-family:courier new,courier,monospace;">&lt;Variable&gt;</span> tags in the policy. The&nbsp;<span style="font-family: 'courier new', courier, monospace;">&lt;Variable&gt;</span>&nbsp;tag specifies the name of the destination variable where the extracted information is stored, and the JsonPath (JSON) or XPATH (XML) to the extracted information. &nbsp;</p>
<p>All&nbsp;<span style="font-family: 'courier new', courier, monospace;">&lt;Variable&gt;</span>&nbsp;tags in the policy are evaluated, so that you can populate multiple variables from a single policy. If the&nbsp;<span style="font-family: 'courier new', courier, monospace;">&lt;Variable&gt;</span>&nbsp;tag does not evaluate to a valid field in the&nbsp;JSON&nbsp;or XML, then the corresponding variable is not created.&nbsp;</p>
<p>The following example shows an Extract Variables policy that populates two variables from the JSON body of a response:</p>
<pre>
&lt;ExtractVariables name="ExtractVariables-3"&gt;
   &lt;Source&gt;response&lt;/Source&gt;
   &lt;JSONPayload&gt;
      &lt;Variable name="latitude" type="float"&gt;
         &lt;JSONPath&gt;$.results[0].geometry.location.lat&lt;/JSONPath&gt;
      &lt;/Variable&gt;
      &lt;Variable name="longitude" type="float"&gt;
         &lt;JSONPath&gt;$.results[0].geometry.location.lng&lt;/JSONPath&gt;
      &lt;/Variable&gt;
   &lt;/JSONPayload&gt;
   &lt;VariablePrefix&gt;geocoderesponse&lt;/VariablePrefix&gt;
&lt;/ExtractVariables&gt;</pre>
<h3>Writing to the same variable in multiple places</h3>
<p>Take care when choosing the names of variables to set. The policy executes sequentially from the first extraction pattern to the last. If the policy writes a value to the same variable from multiple places, the last write in the policy determines the value of the variable. (This may be what you want.)</p>
<p>For example, you want to extract a token value that can be passed either in a query parameter or in a header, as shown below:</p>
<pre>
&lt;!-- If token only in query param, the query param determines the value. 
     If token is found in both the query param and header, header sets value. --&gt;
&lt;QueryParam name="token"&gt;
&nbsp; &lt;Pattern ignoreCase="true"&gt;{tokenValue}&lt;/Pattern&gt;
&lt;/QueryParam&gt;
&nbsp;
&lt;!-- Overwrite tokenValue even if it was found in query parameter. --&gt;
&lt;Header name="Token"&gt;
&nbsp; &lt;Pattern ignoreCase="true"&gt;{tokenValue}&lt;/Pattern&gt;
&lt;/Header&gt;</pre>
<h3 id="elementreference">Controlling what happens when no match occurs</h3>
<p>If the pattern does not match, then the corresponding variable is not created. Therefore, if another policy references the variable, it can cause an error.</p>
<p>One option is to set&nbsp;<span style="font-family: 'courier new', courier, monospace;">&lt;IgnoreUnresolvedVariables&gt;</span>&nbsp;to true in a policy that references the variable to configure the policy to treat any&nbsp;unresolvable&nbsp;variable as an empty string (null):</p>
<pre>
&lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;</pre>
<h2>Element reference</h2>
<p>The element reference describes the elements and attributes of the Extract Variables policy.</p>
<pre>
&lt;ExtractVariables async="false" continueOnError="false" enabled="true" name="Extract-Variables-1"&gt;
   &lt;DisplayName&gt;Extract Variables 1&lt;/DisplayName&gt;
   &lt;Source clearPayload="true|false"&gt;request&lt;/Source&gt;
   &lt;VariablePrefix&gt;myprefix&lt;/VariablePrefix&gt;
   &lt;IgnoreUnresolvedVariables&gt;true|false&lt;/IgnoreUnresolvedVariables&gt;
   &lt;URIPath&gt;
      &lt;Pattern ignoreCase="false"&gt;/accounts/{id}&lt;/Pattern&gt;
   &lt;/URIPath&gt;
   &lt;QueryParam name="code"&gt;
      &lt;Pattern ignoreCase="true"&gt;DBN{dbncode}&lt;/Pattern&gt;
   &lt;/QueryParam&gt;
   &lt;Header name="Authorization"&gt;
      &lt;Pattern ignoreCase="false"&gt;Bearer {oauthtoken}&lt;/Pattern&gt;
   &lt;/Header&gt;
   &lt;FormParam name="greeting"&gt;
      &lt;Pattern&gt;hello {user}&lt;/Pattern&gt;
   &lt;/FormParam&gt;
   &lt;Variable name="request.content"&gt;
       &lt;Pattern&gt;hello {user}&lt;/Pattern&gt;
   &lt;/Variable&gt;
   &lt;JSONPayload&gt;
      &lt;Variable name="name"&gt;
         &lt;JSONPath&gt;{example}&lt;/JSONPath&gt;
      &lt;/Variable&gt;
   &lt;/JSONPayload&gt;
   &lt;XMLPayload stopPayloadProcessing="false"&gt;
      &lt;Namespaces/&gt;
      &lt;Variable name="name" type="boolean"&gt;
         &lt;XPath&gt;/test/example&lt;/XPath&gt;
      &lt;/Variable&gt;
   &lt;/XMLPayload&gt;
&lt;/ExtractVariables&gt;</pre>
<h2>&lt;ExtractVariables&gt; attributes</h2>
<pre>
&lt;ExtractVariables async="false" continueOnError="false" enabled="true" name="Extract-Variables-1"&gt;</pre>
<a href="http://docs.apigee.com/node/18471">Content to be inserted here</a>
<h2>&lt;Source&gt; element</h2>
<p>(Optional) Specifies the variable to be parsed. The value of <code>&lt;Source&gt;</code>&nbsp;defaults to <code>message</code>. The <code>message</code> value is context-sensitive. In a request flow, <code>message</code> resolves to the request message. In a response flow, <code>message</code> resolves to the response message.</p>
<p>While you often use this policy to extract information from a request or response message, you can use it to extract information from any variable. For example, you can use it to extract information from an entity created by the <a href="http://docs.apigee.com/node/422">http://docs.apigee.com/node/422</a>, from data returned by the <a href="http://docs.apigee.com/node/156">http://docs.apigee.com/node/156</a>, or extract information from an XML or JSON object.<br />
	<br />
	If&nbsp;<code>&lt;Source&gt;</code>&nbsp;cannot be resolved, or resolves to a non-message type, the policy will fail to respond.</p>
<pre>
&lt;Source clearPayload="true|false"&gt;request&lt;/Source&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">message</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">String</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>clearPayload</td>
			<td>
				<p>Set to <strong>true</strong> if you want to clear the payload specified in &lt;Source&gt; after extracting data from it.<br />
					<br />
					Use the <code>&lt;clearPayload&gt;</code> option only if the soruce message is not required after ExtractVariables is executed. Setting to <strong>true</strong>&nbsp;frees up the memory used by the message.</p>
			</td>
			<td>
				<p>false</p>
			</td>
			<td>Optional</td>
			<td>Boolean</td>
		</tr>
	</tbody>
</table>
<h2>&lt;VariablePrefix&gt; element</h2>
<p>(Optional) The complete variable name is created by joining the <code>&lt;VariablePrefix&gt;</code>, a dot, and the name you define in {curly braces} in the <code>&lt;Pattern&gt;</code> element or <span style="font-family:courier new,courier,monospace;">&lt;Variable&gt;</span> element. For example: <code>myprefix.id</code>, <code>myprefix.dbncode</code>, or <code>myprefix.oauthtoken.</code></p>
<pre>
&lt;VariablePrefix&gt;myprefix&lt;/VariablePrefix&gt;</pre>
<p>&nbsp;For example, suppose the value of name is "user".</p>
<ul>
	<li>If&nbsp;<code>&lt;VariablePrefix&gt;</code>&nbsp;is not specified, the extracted values are assigned to a variable named&nbsp;<code>user</code>.</li>
	<li>If&nbsp;<code>&lt;VariablePrefix&gt;</code>&nbsp;is specified as myprefix, the extracted values are assigned to a variable named&nbsp;<code>myprefix.user</code>.</li>
</ul>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">String</td>
		</tr>
	</tbody>
</table>
<h2>&lt;IgnoreUnresolvedVariables&gt; element</h2>
<p>(Optional) Set to <code>true</code> to treat any unresolvable variable as an empty string (null). Set to <code>false</code> if you want the policy to throw an error when any referenced variable is unresolvable.</p>
<pre>
&lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">False</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">Boolean</td>
		</tr>
	</tbody>
</table>
<h2>&lt;URIPath&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Extracts a value from the specified URI path of a <span style="font-family:courier new,courier,monospace;">request</span> source message.&nbsp;If the source message resolves to a message type of <span style="font-family:courier new,courier,monospace;">response</span>, then this element does nothing.</p>
<pre>
&lt;URIPath&gt;
   &lt;Pattern ignoreCase="false"&gt;/accounts/{id}&lt;/Pattern&gt;
&lt;/URIPath&gt;
</pre>
<p>Or for multiple <span style="font-family:courier new,courier,monospace;">&lt;Pattern&gt;</span> tags:</p>
<pre>
&lt;URIPath&gt;
   &lt;Pattern ignoreCase="false"&gt;/accounts/{id}&lt;/Pattern&gt;
   &lt;Pattern ignoreCase="false"&gt;/accounts/employees/{id}&lt;/Pattern&gt;
&lt;/URIPath&gt;
</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>ignoreCase</td>
			<td>Specifies to ignore case when matching the patern.</td>
			<td>
				<p>false</p>
			</td>
			<td>Optional</td>
			<td>Boolean</td>
		</tr>
	</tbody>
</table>
<h2>&lt;QueryParam&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Extracts a value from the specified query parameter of a&nbsp;<span style="font-family: 'courier new', courier, monospace;">request</span>&nbsp;source message.&nbsp;If the source message resolves to a message type of&nbsp;<span style="font-family: 'courier new', courier, monospace;">response</span>, then this element does nothing.</p>
<pre>
&lt;QueryParam name="code"&gt;
   &lt;Pattern ignoreCase="true"&gt;DBN{dbncode}&lt;/Pattern&gt;
&lt;/QueryParam&gt;</pre>
<p>If multiple query parameters have the same name, use indexes to reference the parameters:</p>
<pre>
&lt;QueryParam name="w.2"&gt;
   &lt;Pattern ignoreCase="true"&gt;{secondW}&lt;/Pattern&gt;
&lt;/QueryParam&gt;
</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>name</td>
			<td>Specifies the name of the query parameter. If multiple query parameters&nbsp;have the same&nbsp;name, use indexed referencing, where the first instance of the query parameter has no index, the second is at index 2, the third at index 3, etc.&nbsp;</td>
			<td>
				<p>N/A</p>
			</td>
			<td>Required</td>
			<td>String</td>
		</tr>
	</tbody>
</table>
<h2>&lt;Header&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Extracts a value from the specified HTTP header of the specified <span style="font-family:courier new,courier,monospace;">request</span> or <span style="font-family:courier new,courier,monospace;">response</span> message. If multiple headers have the same name, their values are stored in an array.</p>
<pre>
&lt;!-- The name is the actual header name. --&gt;
&lt;Header name="Authorization"&gt;
&lt;!-- Provide a name for your new custom variable here. --&gt;
   &lt;Pattern ignoreCase="false"&gt;Bearer {oauthtoken}&lt;/Pattern&gt;
&lt;/Header&gt;
</pre>
<p>If multiple headers have the same name, use indexes to reference individual headers in the array:</p>
<pre>
&lt;Header name="myHeader.2"&gt;
   &lt;Pattern ignoreCase="true"&gt;{secondHeader}&lt;/Pattern&gt;
&lt;/Header&gt;
</pre>
<p>Or the following to list all the headers in the array:</p>
<pre>
&lt;Header name="myHeader.values"&gt;
   &lt;Pattern ignoreCase="true"&gt;{myHeaders}&lt;/Pattern&gt;
&lt;/Header&gt;
</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>name</td>
			<td>Specifies the name of the header from which you extract the value.&nbsp;If multiple headers have the same&nbsp;name, use indexed referencing, where the first instance of the header has no index, the second is at index 2, the third at index 3, etc. Use <code>.values</code> to get all headers in the array.</td>
			<td>
				<p>N/A</p>
			</td>
			<td>Required</td>
			<td>String</td>
		</tr>
	</tbody>
</table>
<h2>&lt;FormParam&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Extracts a value from the specified form parameter of the specified&nbsp;<span style="font-family: 'courier new', courier, monospace;">request</span>&nbsp;or&nbsp;<span style="font-family: 'courier new', courier, monospace;">response</span>&nbsp;message. Form parameters can be extracted only when the <code>Content-Type</code>&nbsp;header of the specified message is <code>application/x-www-form-urlencoded</code>.</p>
<pre>
&lt;FormParam name="greeting"&gt;
    &lt;Pattern&gt;hello {user}&lt;/Pattern&gt;
&lt;/FormParam&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>name</td>
			<td>The name of the form parameter&nbsp;from which you extract the value.</td>
			<td>
				<p>N/A</p>
			</td>
			<td>Required</td>
			<td>String</td>
		</tr>
	</tbody>
</table>
<h2>&lt;Variable&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Specifies the name of a variable from which to extract a value.&nbsp;</p>
<pre>
&lt;Variable name="myVar"&gt;
    &lt;Pattern&gt;hello {user}&lt;/Pattern&gt;
&lt;/Variable&gt;</pre>
<p>To extract two values from the variable:</p>
<pre>
&lt;Variable name="myVar"&gt;
   &lt;Pattern&gt;hello {firstName} {lastName}&lt;/Pattern&gt;
&lt;/Variable&gt;
</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>name</td>
			<td>The name of the variable from which to extract the value.</td>
			<td>
				<p>N/A</p>
			</td>
			<td>Required</td>
			<td>String</td>
		</tr>
	</tbody>
</table>
<h2>&lt;JSONPayload&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Specifies the JSON-formatted message from which the value of the variable will be extracted.&nbsp;JSON extraction is performed only when message's <span style="font-family:courier new,courier,monospace;">Content-Type</span>&nbsp;header is <span style="font-family:courier new,courier,monospace;">application/json</span>.</p>
<div class="sample-github">
	<p><strong>Learn by doing!</strong><br />
		Check out these Learn Edge examples that show you how to extract data from a JSON response payload. Just follow the instructions in the READMEs.</p>
	<ul>
		<li><a href="https://github.com/apigee/api-platform-samples/tree/master/learn-edge/extract-json-payload">Extract data from a JSON payload</a></li>
		<li><a href="https://github.com/apigee/api-platform-samples/tree/master/learn-edge/extract-json-payload-2">Query for data in a JSON payload</a></li>
	</ul>
</div>
<pre>
&lt;JSONPayload&gt;
   &lt;Variable name="name" type="string"&gt;
      &lt;JSONPath&gt;{example}&lt;/JSONPath&gt;
   &lt;/Variable&gt;
&lt;/JSONPayload&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>&lt;JSONPayload&gt;/&lt;Variable&gt; element</h3>
<p>(Required within the JSONPayload element.) Specifies the variable where the extracted value is assigned. You can include multiple <span style="font-family:courier new,courier,monospace;">&lt;Variable&gt;</span> tags in the <span style="font-family:courier new,courier,monospace;">&lt;JSONPayload&gt;</span> element to populate multiple variables. &nbsp;</p>
<pre>
&lt;Variable name="name" type="string"&gt;
   &lt;JSONPath&gt;{example}&lt;/JSONPath&gt;
&lt;/Variable&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Required within the JSONPayload element.&nbsp;</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h4>Attributes</h4>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>name</td>
			<td>
				<p>Specifies the name of the variable to which the extracted value will be assigned.&nbsp;</p>
			</td>
			<td>
				<p>name</p>
			</td>
			<td>Required</td>
			<td>String</td>
		</tr>
		<tr>
			<td>type</td>
			<td>Specifies the data type of the variable value.</td>
			<td>N/A</td>
			<td>Optional</td>
			<td>
				<p>String. Select from:</p>
				<ul>
					<li>string</li>
					<li>boolean</li>
					<li>integer</li>
					<li>long</li>
					<li>float</li>
					<li>double</li>
					<li>nodeset (returns JSON fragment)</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>
<h3>&lt;JSONPayload&gt;/&lt;Variable&gt;/&lt;JSONPath&gt; element</h3>
<p>(Required within the JSONPayload:Variable element.) Specifies the JSON path used to extract a value from a JSON-formatted message.&nbsp;</p>
<pre>
&lt;Variable name="name"&gt;
   &lt;JSONPath&gt;$.rss.channel.title&lt;/JSONPath&gt;
&lt;/Variable&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Required</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">String</td>
		</tr>
	</tbody>
</table>
<h2>&lt;XMLPayload&gt; element</h2>
<p>(Optional, but see the Presence row in the table below for more information.) Specifies the XML-formatted message from which the value of the variable will be extracted. &nbsp;XML payloads are extracted only when the&nbsp;<code>Content-Type</code>&nbsp;header of the message is&nbsp;<font class="font7"><code>text/xml</code></font>&nbsp;<font class="font0">,&nbsp;</font><font class="font7"><code>application/xml</code></font>&nbsp;<font class="font0">, or&nbsp;</font><font class="font7"><code>application/*+xml</code></font><font class="font0">.</font></p>
<div class="sample-github">
	<p><strong>Learn by doing!</strong></p>
	<p>Check out <a href="https://github.com/apigee/api-platform-samples/tree/master/learn-edge/extract-xml-payload">this Learn Edge example</a> that show you how to extract data from an XML response payload. Just follow the instructions in the README.</p>
</div>
<pre>
&lt;XMLPayload stopPayloadProcessing="false"&gt;
  &lt;Namespaces&gt;
     &lt;Namespace prefix="apigee"&gt;http://www.apigee.com&lt;/Namespace&gt;
     &lt;Namespace prefix="gmail"&gt;http://mail.google.com&lt;/Namespace&gt;
  &lt;/Namespaces&gt;
  &lt;Variable name="name" type="boolean"&gt;
     &lt;XPath&gt;/apigee:test/apigee:example&lt;/XPath&gt;
  &lt;/Variable&gt;
&lt;/XMLPayload&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional. However, you must include at least one of the following: <code>&lt;URIPath&gt;</code>, <code>&lt;QueryParam&gt;</code>, <code>&lt;Header&gt;</code>, <code>&lt;FormParam&gt;</code>, <code>&lt;JSONPayload&gt;</code>, or <code>&lt;XMLPayload&gt;.</code></td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h3>Attributes</h3>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td><code>stopPayloadProcessing</code></td>
			<td>
				<p>Set to <code>true</code> to stop XPath evaluation after one variable is populated. This means only a single variable is populated by the policy.</p>
			</td>
			<td>
				<p>false</p>
			</td>
			<td>Optional</td>
			<td>Boolean</td>
		</tr>
	</tbody>
</table>
<h3>&lt;XMLPayload&gt;/&lt;Namespaces&gt; element</h3>
<p>(Optional) Specifies the namespace to be used in the XPath evaluation. If you're using namespaces in your XPath expressions, you must declare the namespaces here, as shown in the following example.</p>
<pre>
&lt;XMLPayload stopPayloadProcessing="false"&gt;
  &lt;Namespaces&gt;
     &lt;Namespace prefix="apigee"&gt;http://www.apigee.com&lt;/Namespace&gt;
     &lt;Namespace prefix="gmail"&gt;http://mail.google.com&lt;/Namespace&gt;
  &lt;/Namespaces&gt;
  &lt;Variable name="legName" type="string"&gt;
    &lt;XPath&gt;/apigee:Directions/apigee:route/apigee:leg/apigee:name&lt;/XPath&gt;
  &lt;/Variable&gt;
&lt;/XMLPayload&gt;
</pre>
<p>Omit the namespace definition of there is none:</p>
<pre>
&lt;XMLPayload stopPayloadProcessing="false"&gt;
  &lt;Namespaces/&gt;
  &lt;Variable name="legName" type="string"&gt;
    &lt;XPath&gt;/Directions/route/leg/name&lt;/XPath&gt;
  &lt;/Variable&gt;
&lt;/XMLPayload&gt;
</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">String</td>
		</tr>
	</tbody>
</table>
<h4>Attributes</h4>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td><code>prefix</code></td>
			<td>
				<p>The namespace prefix.</p>
			</td>
			<td>
				<p>N/A</p>
			</td>
			<td>Optional</td>
			<td>String</td>
		</tr>
	</tbody>
</table>
<h3>&lt;XMLPayload&gt;/&lt;Variable&gt; element</h3>
<p>(Optional) Specifies variable to which the extracted value will be assigned.</p>
<pre>
&lt;Variable name="name" type="boolean"&gt;
   &lt;XPath&gt;/test/example&lt;/XPath&gt;
&lt;/Variable&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Optional</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
	</tbody>
</table>
<h4>Attributes</h4>
<table border="0" class="table">
	<tbody>
		<tr>
			<th scope="col">Attribute</th>
			<th scope="col">Description</th>
			<th scope="col">Default</th>
			<th scope="col">Presence</th>
			<th scope="col">Type</th>
		</tr>
		<tr>
			<td>name</td>
			<td>
				<p>Specifies the name of the variable to which the extracted value will be assigned.&nbsp;</p>
			</td>
			<td>
				<p>name</p>
			</td>
			<td>Required</td>
			<td>String</td>
		</tr>
		<tr>
			<td>type</td>
			<td>Specifies the data type of the variable value.</td>
			<td>Boolean</td>
			<td>Optional</td>
			<td>
				<p>String. Select from:</p>
				<ul>
					<li>string</li>
					<li>boolean</li>
					<li>integer</li>
					<li>long</li>
					<li>float</li>
					<li>double</li>
					<li>nodeset (returns an XML fragment)</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>
<h3>&lt;XMLPayload&gt;/&lt;Variable&gt;/&lt;XPath&gt; element</h3>
<p>(Required within the XMLPayload:Variable element.) Specifies the XPath defined for the variable. Only XPath 1.0 expressions are supported.</p>
<pre>
&lt;Variable name="name" type="boolean"&gt;
   &lt;XPath&gt;/test/example&lt;/XPath&gt;
&lt;/Variable&gt;</pre>
<p>Example with a namespace. If you use namespaces in your XPath expressions, you must declare the namespaces in the&nbsp;<a href="#xmlpayloadelement-xmlpayloadnamespaceselement"><code>&lt;XMLPayload&gt;&lt;Namespaces&gt;</code></a>&nbsp;section of the policy.</p>
<pre>
&lt;Variable name="name" type="boolean"&gt;
   &lt;XPath&gt;/foo:test/foo:example&lt;/XPath&gt;
&lt;/Variable&gt;</pre>
<table class="pd-table">
	<tbody>
		<tr>
			<td class="pd-td-left">Default:</td>
			<td class="pd-td-right">N/A</td>
		</tr>
		<tr>
			<td class="pd-td-left">Presence:</td>
			<td class="pd-td-right">Required</td>
		</tr>
		<tr>
			<td class="pd-td-left">Type:</td>
			<td class="pd-td-right">String</td>
		</tr>
	</tbody>
</table>
<div class="note">
	<p>Using <code>parent</code>, <code>ancestor</code>, <code>following</code>, and <code>preceding</code> in XPath expressions is not supported in Edge. To get the same matching results, try explicit node name matching or indexing. For example:</p>
	<ul>
		<li><code>&lt;XPath&gt;/Attributes/Attribute[@Name=’foo_attribute']/Value&lt;/XPath&gt;</code><br />
			gets the value of <code>foo_attribute</code>.</li>
		<li><code>&lt;XPath&gt;/Attributes/Attribute[4]/Value&lt;/XPath&gt;</code><br />
			gets the value of the 4th attribute.</li>
	</ul>
</div>
<h2 id="errorcodes">Error reference</h2>
<p><a href="http://docs.apigee.com/node/21281">Content to be inserted here</a></p>
<h2 id="schemas">Schemas</h2>
<div class="sample-github">
	<p>See our <a href="https://github.com/apigee/api-platform-samples/tree/master/schemas/policy">GitHub repository</a>&nbsp;samples for the most recent schemas.</p>
</div>
<h2 id="relatedtopics">Related topics</h2>
<p><a href="http://docs.apigee.com/node/4554">http://docs.apigee.com/node/4554</a></p>
<p><a href="http://docs.apigee.com/node/243">http://docs.apigee.com/node/243</a></p>
<p>&nbsp;</p>
