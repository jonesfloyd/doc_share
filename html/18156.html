<h1> Using third-party OAuth tokens </h1>
<p>In this topic, we'll discuss how to store externally generated access tokens, refresh tokens, or auth codes as values in Edge-generated token or code metadata. This technique allows you to use the stored, third-party token value to make API proxy calls that can be validated by the Edge OAuth2 authentication service, just as if the token values were generated by Edge.&nbsp;</p>
<h2>Example</h2>
<p style="font-size: 12px;">If you want to see a working example that illustrates the technique described in this topic, take a look at the&nbsp;<a href="https://github.com/dzuluaga/apigee-tutorials/tree/master/apiproxies/musicapi-oauth-delegated-authentication">Apigee Delegated Token Management sample</a>.</p>
<h2>What is this?</h2>
<p>Suppose you have an existing authorization system in place, and you would like to use the token or code values generated by that system in place of the OAuth2 token or code values that Edge generates. The technique described in this topic lets you store an externally generated token or auth code value in Edge-generated token or code metadata. You can then make secure API proxy requests with the substituted token or code, and Edge will validate them as if they were generated by Edge.&nbsp;</p>
<p>For example, the metadata for an Edge-generated access token might look like the following, where the <code>access_token</code> attribute is a random string of letters and numbers generated by Edge. Remember that the value of the<strong> access_token</strong> attribute is essentially the "lookup key" for this metadata. When Edge receives a token in a request, it looks up this information and uses it to determine if the token is valid or not.</p>
<pre>
{
  "issued_at": "1469735625687",
  "application_name": "06947a86-919e-4ca3-ac72-036723b18231",
  "scope": "",
  "status": "approved",
  "api_product_list": "[implicit-test]",
  "expires_in": "99",
  "developer.email": "joe@weathersample.com",
  "token_type": "BearerToken",
  "client_id": "U9AC66e9YFyI1yqaXgUF8H6b9wUN1TLk",
  <strong>"access_token": "zBC90HhCGmGlaMBWeZAai2s3za5j",</strong>
  "organization_name": "wwitman",
  "refresh_token_expires_in": "0",
  "refresh_count": "0"
}</pre>
<p>On the other hand, by following the steps in this topic, you can generate a token so that its <strong>access_token</strong> value is the value of a token generated by an external authentication service. For example, the token might be <strong>1234abcd</strong> as shown in this example:</p>
<pre>
{
  "issued_at": "1469735739602",
  "application_name": "06947a86-919e-4ca3-ac72-036723b18231",
  "scope": "",
  "status": "approved",
  "api_product_list": "[implicit-test]",
  "expires_in": "99",
  "developer.email": "joe@weathersample.com",
  "token_type": "BearerToken",
  "client_id": "U9AC66e9YFyI1yqaXgUF8H6b9wUN1TLk",
  <strong>"access_token": "1234abcd"</strong>,
  "organization_name": "wwitman",
  "refresh_token_expires_in": "0",
  "refresh_count": "0"
}
</pre>
<p>In this case, you could make authenticated requests to Edge with the bearer token <code>1234abcd</code> and Edge will be able to validate it. The same basic pattern applies to authorization codes and refresh tokens.</p>
<p>The key to using this technique is that at some point, before generating a token or auth code on Edge, you need to make a service callout to an external identity provider or authentication service. There are various ways to do this, but a Service Callout policy is commonly used. When you verify that you got back a valid token, you can then follow the steps described in this topic to generate a token (or auth code) in the Edge system that will use the third-party token value in place of the one that would have been generated by Edge. This way, you can make authenticated API proxy calls to Edge using the third-party token as if it were a token generated by the Edge OAuth2 authentication service itself.&nbsp;</p>
<h2>How to use third-party OAuth on Apigee</h2>
<p>To use tokens from third-party OAuth systems in Apigee Edge, you need to do these things:</p>
<p><strong>1. Configure the OAuthV2 policy</strong></p>
<p>The OAuthV2 policy is the policy that you use to generate new access tokens, refresh tokens, and auth codes. Here's how you configure the policy to work with externally generated tokens or codes:</p>
<ul>
	<li>For the purpose of generating an access token, determine whether or not you want Edge to validate the required client credentials from its own authorization store or instead use credentials that will be recognized by the external authorization server. If you want to validate the Edge-stored credentials, set <code>&lt;ExternalAuthorization&gt;</code> element set to <code>false</code>. If you want to use the external authorization service to validate the credentials, set <code>&lt;ExternalAuthorization&gt;</code> to <code>true</code>. In the latter case, it is up to you to develop a policy flow where the externally recognized credentials are sent to the external auth service and, if valid, the returned access token is then used, as explained in the next bullet.</li>
</ul>
<ul>
	<li>Configure one of these OAuthV2 elements:&nbsp;<code>&lt;ExternalAccessToken&gt;</code>, <code>&lt;ExternalRefreshToken&gt;</code>, or&nbsp;<code>&lt;ExternalAuthorizationCode&gt;</code>. These elements specify a <strong>flow variable</strong> where Edge should look to find the externally-generated access token, refresh token, or authorization code. It's up to you to implement policies/logic to call the external identity service, determine if the callout succeeded or not, and place the external token in the variable. For example, the following configuration tells Edge to look for the token in a request query parameter; however, it could be assigned to any flow variable accessible to the proxy.</li>
</ul>
<blockquote>
	<pre>
&lt;ExternalAccessToken&gt;request.queryparam.external_access_token&lt;/ExternalAccessToken&gt;</pre>
</blockquote>
<ul>
	<li>Set the <code>&lt;StoreToken&gt;</code> element in OAuthV2 to <code>true</code>.</li>
</ul>
<p><strong>2. Set the oauth_external_authorization_status flow variable to true</strong></p>
<ul>
	<li><strong>Before the OAuthV2 policy executes</strong>, you must set the flow variable <code>oauth_external_authorization_status</code> to <code>true</code>.</li>
</ul>
<p style="margin-left: 40px;">Typically, this variable is set to true or false based on a service callout to a third-party authorization service. You can look at the service callout response to determine of the callout succeeded or not and set the variable accordingly. Take a look at the <a href="http://apigee.com/docs/api-services/reference/service-callout-policy">ServiceCallout policy</a> for details. A common technique for setting this variable is to use an <a href="http://apigee.com/docs/api-services/reference/assign-message-policy">AssignMessage policy</a> with the AssignVariable element, like this:</p>
<blockquote>
	<pre>
&lt;AssignMessage name="AssignMessage-SetVariable"&gt;
    &lt;DisplayName&gt;Assign Message - Set Variable&lt;/DisplayName&gt;
    &lt;AssignVariable&gt;
        &lt;Name&gt;oauth_external_authorization_status&lt;/Name&gt;
        &lt;Value&gt;true&lt;/Value&gt;
    &lt;/AssignVariable&gt;
    &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
&lt;/AssignMessage&gt;
</pre>
</blockquote>
<p><strong>Example</strong></p>
<p>The following OAuthV2 policy generates an Apigee Edge access token given that Edge finds a token value in the flow variable <code>request.queryparam.external_access_token</code>. The location can be any variable, but in this case, it's the value of a query parameter:</p>
<pre>
&lt;OAuthV2 name="OAuth-v20-Store-External-Token"&gt;
    &lt;DisplayName&gt;OAuth v2.0 1&lt;/DisplayName&gt;
    &lt;Attributes/&gt;
    &lt;ExternalAccessToken&gt;request.queryparam.external_access_token
    &lt;/ExternalAccessToken&gt;
    &lt;ExternalAuthorization&gt;true&lt;/ExternalAuthorization&gt;
    &lt;Operation&gt;GenerateAccessToken&lt;/Operation&gt;
    &lt;GenerateResponse enabled="true"&gt;
        &lt;Format&gt;FORM_PARAM&lt;/Format&gt;
    &lt;/GenerateResponse&gt;
    &lt;ReuseRefreshToken&gt;false&lt;/ReuseRefreshToken&gt;
    &lt;StoreToken&gt;true&lt;/StoreToken&gt;
    &lt;SupportedGrantTypes&gt;
        &lt;GrantType&gt;client_credentials&lt;/GrantType&gt;
    &lt;/SupportedGrantTypes&gt;
    &lt;Tokens/&gt;
&lt;/OAuthV2&gt;</pre>
<p>Given the above configuration, you can request an access token as follows, where you pass in the value of the externally generated token in a query parameter. Again, how you obtain this value is beyond the scope of this topic. But a common technique would be to use Edge policies to parse the response from a service callout to the external auth service, and store the value of the returned token in a variable.</p>
<pre>
curl https://testmyapi-test.apigee.net/oauth-delegated/generatetoken?external_access_token=123456 \ 
-d 'client_id=sxnS7SddD6494Akbqk74ej4SmvvqjL0O&amp;grant_type=client_credentials'</pre>
<div class="note">
	<p><strong>Important to note:</strong> Normally, with the client credentials grant type, you need to provide a Basic Authentication header with the encoded Client ID and Client Secret. However, in this case, you do <strong>not</strong> need to provide that header. Note that the <code>client_id</code> is&nbsp;still&nbsp;expected in the request and&nbsp;will be validated. &nbsp;By default, Edge expects the <code>client_id</code> to be sent as&nbsp;<code>x-www-form-urlencoded</code> data.</p>
</div>
<p>In this case, Edge will generate an access token, with an <strong><code>access_token</code></strong> value of <code><strong>123456</strong></code>. The token metadata might look something like this. And, as you can see, this token metadata has Apigee-specific properties that will enable it to work with developers, developer apps, and products registered on Edge.</p>
<pre>
{
  "issued_at" : "1415467907287",
  "application_name" : "9d3f4de-e501-4836-9bdd-f55e1d4b923",
  "scope" : "WRITE",
  "status" : "approved",
  "api_product_list" : "[PremiumWeatherAPI]",
  "expires_in" : "1799",
  "developer.email" : "tesla@weathersample.com",
  "organization_id" : "0",
  "token_type" : "BearerToken",
  "client_id" : "sxnS7Sdd6494Akb74ej4SmvvqjL0O",
  "access_token" : "123456"
  "organization_name" : "testmyapi",
  "refresh_token_expires_in" : "0",
  "refresh_count" : "0"
}
</pre>
<p>Finally, you might call an API like this, with <code>123456</code> as the OAuth2 bearer token:</p>
<pre>
curl
'https://docs-test.apigee.net/oauth-delegated/music?func=getSong&amp;artist=radiohead&amp;fmt=json'
-H 'Authorization:Bearer 123456'
</pre>
<p>In theory, you could apply this pattern with any third-party OAuth2 authorization service, like Google or Twitter.</p>
